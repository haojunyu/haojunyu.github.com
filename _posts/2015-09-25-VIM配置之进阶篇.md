---
layout: default
title:  Vim配置之进阶篇
category:   [Ubuntu, Vim]
comments:   true
---
在上一篇博文[Vim配置之入门篇]({{site.baseurl}}/2015/08/31/VIM配置之入门篇.html)中，只是大略介绍了Vim的基本配置以及几个常用的使用插件，但是在后面的使用中发现该配置的Vim并不是很好用，特别是minibuffer，taglist，fileexplore直接存在冲突，而且它的插件管理也比较麻烦。本篇博文主要就是解决这两个问题以及尝试一些更适合码农的插件。



## 简介
之前使用Vim的初衷一方面是其插件的强大，更主要的方面是适合装13。但是随着对Vim更多的了解，才发现Vim的强大还是有缘由的，从下面的评价足以看出：
> * 世界上只有三种编辑器，EMACS、VIM和其它  
> * VIM is the God of editors, EMACS is God’s editor  
> * EMACS is actually an OS which pretends to be an editor

根据上篇博文中的配置在日常使用的出现的问题，在此给出解决方案，对于插件间的冲突问题是用tagbar取代taglist，而插件管理是采用bundle插件。对于vim里面实用方便的插件的确有不少。


## 高效插件
vim的插件很多，而且功能很强大，非常强大。官网的插件地址在[这里][vim_script]。

* vundle  
vundle是个用来管理vim插件的插件，它高效的利用了git，使得vim插件的安装，更新和卸载都交由vundle管理，从而将使用者从vim安装配置中解放出来。
	1. 安装vundle
		
		```sh
		git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
		```
	2. 使用vundle管理vim插件
		1. 在[Vim Script][vim_script]选好想要使用的插件
		2. 在vim配置文件.vimrc中添加`Plugin plugin_name`
		3. 执行Vundle初始化命令`:PluginInstall`，插件就安装好了
		4. 常用命令  
		
		```sh
		# 更新插件
		:PluginInstall!
		# 清除不再使用的插件
		:PluginClean
		# 列出所有插件
		:PluginList
		# 查找插件
		:PluginSearch
		```
	3. vundle在.vimrc中的配置
		
		```vim
		" 文件类型检测关闭[必须]（/usr/share/vim/vim74/filetype.vim）
		filetype off
		" 设置runtime path包含Vundle的路径并且初始化
		set rtp+=~/.vim/bundle/Vundle.vim
		" 设置plugins安装地址
		call vundle#begin('~/.vim/bundle/')
		" 安装Vundle，让其管理插件[必须]
		Plugin 'gmarik/Vundle.vim'

		""""""""""""""""""""""""""""""""""
		" Vundle插件安装样例:
		" 插件在github上
		" Plugin 'tpope/vim-fugitive'
		" 插件来自网页http://vim-scripts.org/vim/scripts.html
		" Plugin 'L9'
		" Git插件，但插件不在Github上
		" Plugin 'git://git.wincent.com/command-t.git'
		" 插件在本地机器上 (i.e. when working on your own plugin)
		" Plugin 'file:///home/gmarik/path/to/plugin'
		" The sparkup vim script is in a subdirectory of this repo called vim.
		" Pass the path to set the runtimepath properly.
		" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
		" 使用用户名来避免插件冲突 ie. L9
		" Plugin 'user/L9', {'name': 'newL9'}
		""""""""""""""""""""""""""""""""""

		" 所有插件的添加在end之前[必须]
		call vundle#end()            
		" 文件类型对应的插件[必须]（/usr/share/vim/vim74/ftplugin.vim）
		filetype plugin on
		" 文件类型对应的缩进文件
		filetype indent on
		```
		

* The-NERD-tree  
NERDTree是Vim最常用的插件之一，可以在Vim运行时显示目录和文件结构，类似TextMate左侧的文件浏览器，但操作起来更为方便，你可以在手不离开键盘的情况下快速浏览文件，并在文件和文件夹之间进行切换。其样例如下图所示：
![NERDTree]({{site.baseurl}}/assets/images/the-NERD-tree.gif)
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle')
		" 在Vim的编辑窗口中树状显示文件目录[The-NERD-tree]
		Plugin 'The-NERD-tree'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" The-NERD-tree配置
		""""""""""""""""""""""""""""""""""
		" 不显示缓冲文件，中间文件
		let NERDTreeIgnore=[ '.pyc$', '.pyo$', '.obj$', '.o$', '.so$', '.egg$', '^.git$', '^.svn$', '^.hg$' ]
		" 只剩一个NERDTree窗口时退出vim
		autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") &&b:NERDTreeType == "primary") | q | endif
		" <F9>打开/关闭文件管理器
		nnoremap <silent> <F9> :NERDTreeToggle<CR>
		```
		
* The-NERD-Commenter  
这个插件也是必备的，主要自动注释内容。当你xml自然是xml注释，当你是java自然就是java的注释规则。其样例如下图所示：
![nerdcommenter]({{site.baseurl}}/assets/images/nerdcommenter.gif)
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 快速添加/去除注释
		Plugin 'The-NERD-Commenter'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" The-NERD-Commenter配置
		""""""""""""""""""""""""""""""""""
		" 注释的时候自动加个空格, 强迫症必配
		let g:NERDSpaceDelims=1
		" mm智能判断加上/解开注释
		map mm <leader>c<space>
		```
		
* ctrlp
这是个文件查找的插件，其功能和NERDTree有点类似，但是还是有点区别吧。其样例如下图所示：
![nerdcommenter]({{site.baseurl}}/assets/images/vim-ctrlp.gif)
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 文件搜索
		Plugin 'kien/ctrlp.vim'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" ctrlp配置
		""""""""""""""""""""""""""""""""""
		" 设置CtrlP的本地工作目录，0代表不设置该功能
		let g:ctrlp_working_path_mode=0
		" ctrlp窗口在底部
		let g:ctrlp_match_window_bottom=1
		" ctrlp窗口最大高度为15行
		let g:ctrlp_max_height=15
		" 窗口
		let g:ctrlp_match_window_reversed=0
		" 最近打开的文件的个数
		let g:ctrlp_mruf_max=500
		" 记录但去掉重复的软链接
		let g:ctrlp_follow_symlinks=1
		" <Ctrl-f>启动文件查找
		let g:ctrlp_map = '<c-f>'
		" Ctrlp启动文件查找
		let g:ctrlp_cmd = 'CtrlP'
		" 相当于mru功能，show recently opened files
		map <c-p> :CtrlPMRU<CR>
		" 忽略以下文件类型
		set wildignore+=*/tmp/*,*.so,*.swp,*.zip
		" 忽略以下文件目录
		let g:ctrlp_custom_ignore = {'dir':  '/].(git|hg|svn|rvm)$','file': '(exe|so|dll|zip|tar|tar.gz)$'}
		```
		
* ctags  
ctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。
    1. 安装exuberant-ctags工具
    
        ```sh
        sudo apt-get install exuberant-ctags
        ```
    2. 创建C++代码库索引
        1. 下载[libstdc++](http://www.vim.org/scripts/download_script.php?src_id=9178)头文件,包含c++中STL，streams等。
        2. 解压到~/.vim/tags目录后执行ctags命令
            
            ```sh
            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src
            mv tags ~/.vim/tags/cpptag
            ```
        3. 在.vimrc中设置
        
            ```vim
            set tags+=~/.vim/tags/cpptag
            ```
    3. 创建gcc代码库索引
        1. ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。
            
            ```sh
            sudo apt-get install build-essential
            ```
        2. 拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令
        
            ```sh
            cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc
            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc
            mv tags ~/.vim/tags/gcctag
            ```
        3. 在.vimrc中设置
            
            ```vim
            set tags+=~/.vim/tags/gcctag
            ```

* tagbar  
tagbar插件是和taglist功能类似的插件，但是它比taglist更优秀，并且能和NERDTree完美配合。
	1. tagbar的优势
		* 支持头文件的函数列表显示  
		细心的读者可能会发现，tagbar对函数的可见级别也是做了区分的，分别用+ – # 并配合着色来做了区分
		* 对面向对象的支持更好  
		taglist虽然也会列出类列表，但是整体还是很不直观
		* 自动根据文件修改时间来重建  
		taglist在这一点上体验就很不好，其实明明可以通过这种时间戳的方式来实现
	2. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 替换taglist的插件[tagbar]
		Plugin 'majutsushi/tagbar'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" tagbar配置
		""""""""""""""""""""""""""""""""""
		" 启动时自动focus
		let g:tagbar_autofocus=1
		" <F10>打开/关闭Tagbar
		nnoremap <silent> <F10> :TagbarToggle<CR>
		```

* rainbow  
这个插件也是必备的，该插件的主要功能是给配对的(){}[]不同的颜色来区别，非常方便看括号的作用域
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 括号显示增强
		Plugin 'luochen1990/rainbow'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" rainbow配置
		""""""""""""""""""""""""""""""""""
		" rainbow激活
		let g:rainbow_active = 1
		```
	2. 给rainbow添加自动启动功能
		
		```vim
		if (exists('g:rainbow_active') && g:rainbow_active)
			auto syntax * call rainbow#hook()
			auto colorscheme * call rainbow#show()
			" 下面这命令使rainbow在vim启动时被打开
			autocmd VimEnter * nested call rainbow#toggle()
		endif
		```


* [syntastic][syntastic]  
这是一个非常有用的插件，它能够实时的进行语法和编码风格的检查，利用它几乎可以做到编码完成后无编译错误。并且它还集成了静态检查工具：lint，可以让你的代码更加完美。更强大的它支持近百种编程语言，像是一个集大成的实时编译器。出现错误之后，可以非常方便的跳转到出错处。其样例如下图所示：
![nerdcommenter]({{site.baseurl}}/assets/images/vim-syntastic.png)
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 语义高亮
		Plugin 'scrooloose/syntastic'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" syntastic配置
		""""""""""""""""""""""""""""""""""
		" 首次打开和保存时都要进行语义检查
		let g:syntastic_check_on_open = 1  
		" 设置错误提示符'x'
		let g:syntastic_error_symbol = 'x'  
		" 设置警告提示符'!'
		let g:syntastic_warning_symbol = '!'  
		" 当鼠标放在错误行则显示错误信息
		let g:syntastic_enable_balloons = 1  
		" 保存退出时不用进行语义检测
		let g:syntastic_check_on_wq = 0
		" 编译有误则错误窗口显示，否在不显示
		let g:syntastic_auto_loc_list = 1
		" 错误总会填充到错误窗口
		let g:syntastic_always_populate_loc_list = 1
		```
		



* [YouCompleteMe][youcompleteme]   
YouCompleteMe对代码的补全完全达到了编译器级别，绝不弱于Visual Assist。它是基于LLVM/clang，一个Apple公司为了代替GNU/GCC而支持的编译器，正因为YouCompleteMe有了编译器的支持，而不再像以往的插件一样基于文本来进行匹配，所以准确率才如此之高。而且，它是C/S架构，会在本机创建一个服务器端，利用clang来解析代码，然后将结果返回给客户端，所以也就解决了VIM是单线程而造成的各种补全插件速度奇慢的诟病，在使用时，几乎感觉不到任何的延时，体验达到了Visual Assist的级别。  
YouCompleteMe除了补全以外，还有一个非常重要的作用：代码跳转，同样可以达到编译器级别的准确度，媲美Visual Assist与Source Insight。其样例如下图所示：
![nerdcommenter]({{site.baseurl}}/assets/images/youcompleteme.gif)
	1. 安装必备软件
		
		```sh
		sudo apt-get install clang llvm cmake
		```
	1. 手动编译
	
		```sh
		cd ~/.vim/bundle/YouCompleteMe
		./install.sh --clang-completer
		```
	1. 在vim中的安装和配置
	
		```vim
		call vundle#begin('~/.vim/bundle/')
		" 自动补全
		Plugin 'Valloric/YouCompleteMe'
		call vundle#end()  
		
		""""""""""""""""""""""""""""""""""
		" YouCompleteMe配置
		""""""""""""""""""""""""""""""""""
		" 设置YCM配置文件的路径
		let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'
		" 开启关键字语法检测
		let g:ycm_seed_identifiers_with_syntax = 1 
		" 自动触发补全
		let g:ycm_auto_trigger = 1 
		" YCM触发的条件
		let g:ycm_semantic_triggers = {  
		\ 'c' : ['->' , '.'],
		\ 'cpp,objcpp' : ['->','.','::'],
		\ 'java,javascript,python,scala' : ['.'],
		\ 'ruby' : ['.','::'],
		\}
		" 不用每次询问.ycm_extra_conf.py位置
		let g:ycm_confirm_extra_conf=0
		" YCM也从tags文件中收集标识符
		let g:ycm_collect_identifiers_from_tags_files=1
		" 当输入注释的时候不用弹出提示
		let g:ycm_complete_in_comments=0
		" 当输入字符的时候弹出提示
		let g:ycm_complete_in_strings=1
		```





## 参考文献
1. [有趣的vim游戏][vim_adventures]
2. [Vim学习指南][vim_progressively]
3. [vim plugin][vim_plugin]
3. [Vim Script][vim_script]
4. [Vim配置及说明——IDE编程环境][vim_ide]
5. [高效vim插件][vim_plugin2]
6. [VIM助记图][Vim_Cheat_Sheet]
7. [Vimer的程序世界][vimer]
8. [vimium][vimium]
9. [youcompleteme][youcompleteme]
9. [syntastic][syntastic]

[vim_adventures]:	http://vim-adventures.com/
[vim_progressively]:	http://www.oschina.net/translate/learn-vim-progressively
[vim_plugin]:		http://my.oschina.net/swuly302/blog/156784
[vim_script]:		http://vim-scripts.org/vim/scripts.html
[vim_ide]:			http://www.it165.net/pro/html/201404/11505.html
[vim_plugin2]:		http://my.oschina.net/swuly302/blog/156784
[Vim_Cheat_Sheet]:	http://overapi.com/vim/
[vimer]:			http://www.vimer.cn/
[vimium]:			https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb
[youcompleteme]:	http://valloric.github.io/YouCompleteMe/
[syntastic]:		https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt
